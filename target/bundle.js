/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./dist/bracket-mode.js":
/*!******************************!*\
  !*** ./dist/bracket-mode.js ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BracketMode = void 0;\nconst model_1 = __webpack_require__(/*! ./model */ \"./dist/model.js\");\nclass BracketMode {\n    _teams = [];\n    _elimnatedTeams = [];\n    _matches = [];\n    tournamentOver = false;\n    _maxNumberOfTeams = -1;\n    _mode;\n    get mode() {\n        return this._mode;\n    }\n    setProperties(m) {\n        console.log(m);\n        if (m._teams) {\n            this._teams = m._teams.map((team) => model_1.Team.from(team));\n        }\n        this._elimnatedTeams = m._elimnatedTeams.map((team) => model_1.Team.from(team));\n        this._matches = m._matches.map((match) => model_1.Match.from(match, this._teams.concat(this._elimnatedTeams)));\n        this.tournamentOver = m.tournamentOver;\n        this._maxNumberOfTeams = m._maxNumberOfTeams;\n        this._mode = m._mode;\n    }\n    constructor(mode) {\n        this._mode = mode;\n    }\n    getWaitingMatches() {\n        return [];\n    }\n    win(match, winner, canDraw) {\n        console.log(this.isOver(), winner);\n        if (this.isOver()) {\n            return;\n        }\n        const teams = match.getTeams();\n        if (!winner) {\n            if (!canDraw) {\n                throw Error('Matches cannot end in a draw!');\n            }\n            if (!(teams[0] && teams[1])) {\n                throw new Error('Cannot draw free round');\n            }\n            // match is a draw\n            teams[0].draw();\n            teams[1].draw();\n            return;\n        }\n        if (!(winner.equals(teams[0]) || winner.equals(teams[1]))) {\n            throw new Error('team is not part of the match');\n        }\n        if (this.eliminatesTeam()) {\n            if (winner.equals(teams[0])) {\n                if (teams[1]) {\n                    this.teams = this.teams.filter((val) => !val.equals(teams[1]));\n                    this.eliminated.push(teams[1]);\n                }\n            }\n            else {\n                if (teams[0]) {\n                    this.teams = this.teams.filter((val) => !val.equals(teams[0]));\n                    this.eliminated.push(teams[0]);\n                }\n            }\n        }\n        match.played(winner);\n    }\n    sortTeams() {\n        this._teams = this._teams\n            .filter((team) => team)\n            .sort((a, b) => a.compare(b));\n        return this._teams;\n    }\n    startTournament() {\n        this.tournamentOver = false;\n        if (this.teams.length <= 2) {\n            this.matches.splice(0);\n            this.matches.push(new model_1.Match(this.teams[0] || undefined, this.teams[1] || undefined, 0));\n        }\n        this.sortTeams();\n    }\n    endTournament() {\n        this.teams = this.teams.filter((team) => team !== null);\n        this.tournamentOver = true;\n    }\n    setTeams(...teams) {\n        this.teams = teams;\n    }\n    set teams(teams) {\n        if (teams.length >\n            (this.maxNumberTeams < 0 ? teams.length : this.maxNumberTeams)) {\n            throw new Error('<ERROR> Number of teams is bigger than maximum allowed number of teams!');\n            return;\n        }\n        this._teams = teams;\n    }\n    get teams() {\n        return this._teams;\n    }\n    get eliminated() {\n        return this._elimnatedTeams;\n    }\n    get eliminatedTeams() {\n        return this._elimnatedTeams;\n    }\n    get matches() {\n        return this._matches.sort((a, b) => a.matchOrder - b.matchOrder);\n    }\n    set matches(matches) {\n        this._matches = matches;\n    }\n    set maxNumberTeams(value) {\n        this._maxNumberOfTeams = value;\n    }\n    get maxNumberTeams() {\n        return this._maxNumberOfTeams;\n    }\n}\nexports.BracketMode = BracketMode;\n//# sourceMappingURL=bracket-mode.js.map\n\n//# sourceURL=webpack://tournament-bracket/./dist/bracket-mode.js?");

/***/ }),

/***/ "./dist/bracket-type.js":
/*!******************************!*\
  !*** ./dist/bracket-type.js ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Tournament = exports.Swiss = exports.RoundRobin = void 0;\nconst round_robin_1 = __webpack_require__(/*! ./round-robin */ \"./dist/round-robin.js\");\nObject.defineProperty(exports, \"RoundRobin\", ({ enumerable: true, get: function () { return round_robin_1.RoundRobin; } }));\nconst swiss_1 = __webpack_require__(/*! ./swiss */ \"./dist/swiss.js\");\nObject.defineProperty(exports, \"Swiss\", ({ enumerable: true, get: function () { return swiss_1.Swiss; } }));\nconst tournament_1 = __webpack_require__(/*! ./tournament */ \"./dist/tournament.js\");\nObject.defineProperty(exports, \"Tournament\", ({ enumerable: true, get: function () { return tournament_1.Tournament; } }));\n//# sourceMappingURL=bracket-type.js.map\n\n//# sourceURL=webpack://tournament-bracket/./dist/bracket-type.js?");

/***/ }),

/***/ "./dist/index.js":
/*!***********************!*\
  !*** ./dist/index.js ***!
  \***********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tournament_bracket_1 = __webpack_require__(/*! ./tournament-bracket */ \"./dist/tournament-bracket.js\");\nlet tournament;\nconst teams = [];\nconst modi = [];\nlet matches = [];\nlet createDiv, tournamentDiv, overlay;\nlet teamsDiv;\nlet teamnameInput;\nlet modiDiv;\nlet modusSelect;\nlet createTournamentButton;\nlet nextRoundButton, nextModusButton, startTournamentButton;\nlet buttonsDiv;\nlet teamId = 0;\nlet tablesDiv;\nlet xDiff, yDiff, targetElement;\ndocument.addEventListener('DOMContentLoaded', () => {\n    teamsDiv = document.getElementsByClassName('teams')[0];\n    modiDiv = document.getElementsByClassName('modi')[0];\n    createDiv = document.getElementsByClassName('create-screen')[0];\n    tournamentDiv = document.getElementsByClassName('tournament-screen')[0];\n    tablesDiv = document.getElementsByClassName('tables')[0];\n    overlay = document.getElementsByClassName('overlay')[0];\n    createTournamentButton = document.getElementById('createTournament');\n    createTournamentButton.addEventListener('click', () => createTournament(false, 5));\n    const addTeamButton = document.getElementById('addTeam');\n    addTeamButton.addEventListener('click', () => {\n        addTeam();\n        teamnameInput.value = '';\n    });\n    teamnameInput = document.getElementById('teamnameInput');\n    teamnameInput.addEventListener('input', (event) => {\n        addTeamButton.disabled = disableAddTeam(event.target.value);\n    });\n    const addModusButton = document.getElementById('addModus');\n    addModusButton.addEventListener('click', () => {\n        addModus();\n        modusSelect.value = 'roundRobin';\n    });\n    modusSelect = document.getElementById('selectModus');\n    buttonsDiv = document.getElementsByClassName('buttons')[0];\n    nextRoundButton = document.getElementById('nextRoundButton');\n    nextRoundButton.addEventListener('click', startNextRound);\n    startTournamentButton = document.getElementById('startTournamentButton');\n    startTournamentButton.addEventListener('click', startTournament);\n    nextModusButton = document.getElementById('nextModusButton');\n    nextModusButton.addEventListener('click', () => {\n        nextModus();\n    });\n    for (let i = 1; i <= 17; ++i) {\n        teamnameInput.value = `Team ${i}`;\n        addTeam();\n    }\n    if (sessionStorage.getItem('tournament')) {\n        overlay.classList.remove('hidden');\n        overlay.classList.add('load-tournament');\n        document\n            .getElementById('loadTournamentButton')\n            .addEventListener('click', loadTournament);\n        document\n            .getElementById('createNewTournamentButton')\n            .addEventListener('click', () => {\n            overlay.classList.add('hidden');\n            overlay.classList.remove('load-tournament');\n        });\n    }\n});\nfunction startNextRound() {\n    matches = nextRound();\n    for (let i = 0; i < tournament.nrSimultaneousGames; ++i) {\n        const table = tablesDiv.children[i];\n        if (!matches[i]) {\n            table.getElementsByClassName('team1')[0].innerHTML = '';\n            table.getElementsByClassName('team2')[0].innerHTML = '';\n            table.id = '';\n            continue;\n        }\n        table.classList.remove('over');\n        const teams = matches[i].getTeams();\n        table.getElementsByClassName('team1')[0].classList.remove('winner');\n        table.getElementsByClassName('team2')[0].classList.remove('winner');\n        if (matches[i].winner) {\n            const winner = teams.indexOf(matches[i].winner) + 1;\n            table.getElementsByClassName(`team${winner}`)[0].classList.add('winner');\n            table.classList.add('over');\n        }\n        table.getElementsByClassName('team1')[0].innerHTML = `<span>${teams[0].name}</span>`;\n        table.getElementsByClassName('team2')[0].innerHTML = `<span>${teams[1].name}</span>`;\n        table.id = `match__${matches[i].matchOrder}`;\n    }\n    buttonsDiv.classList.remove('next-round');\n}\nfunction loadTournament() {\n    tournament = tournament_bracket_1.TournamentBracket.from(JSON.parse(sessionStorage.getItem('tournament')));\n    overlay.classList.add('hidden');\n    overlay.classList.remove('load-tournament');\n    createDiv.classList.add('hidden');\n    tournamentDiv.classList.remove('hidden');\n    addTables();\n    updateScore();\n    if (tournament.modusOver()) {\n        nextModus();\n    }\n    else {\n        startNextRound();\n    }\n}\nfunction createTournament(canDraw, nrSimultaneousGames) {\n    tournament = new tournament_bracket_1.TournamentBracket(canDraw);\n    tournament.nrSimultaneousGames = nrSimultaneousGames;\n    tournament.setModi(...modi);\n    tournament.setTeams(...teams);\n    tournament.start();\n    // console.log('created tournament', tournament);\n    createDiv.classList.add('hidden');\n    tournamentDiv.classList.remove('hidden');\n    addTables();\n    updateScore();\n    buttonsDiv.classList.add('start-tournament');\n}\nfunction startTournament() {\n    buttonsDiv.classList.remove('start-tournament');\n    startNextRound();\n    sessionStorage.setItem('tournament', JSON.stringify(tournament));\n}\nfunction addTeam() {\n    const id = `team_${teamId++}`, name = teamnameInput.value.trim();\n    const t = new tournament_bracket_1.Team(id, name, 1000);\n    teams.push(t);\n    createTeamDiv(id, name);\n    createTournamentButton.disabled = isTournamentButtonDisabled();\n}\nfunction removeTeam(id) {\n    teams.splice(teams.findIndex((team) => team.id === id), 1);\n    const div = document.getElementsByClassName(`team_${id}`)[0];\n    div.remove();\n    createTournamentButton.disabled = isTournamentButtonDisabled();\n}\nfunction updateTeamName(teamId, newTeamName) {\n    const index = teams.findIndex((team) => team.id === teamId);\n    teams[index] = new tournament_bracket_1.Team(teamId, newTeamName, 1000);\n}\nfunction addModus() {\n    const index = 0;\n    const id = `modus_${index}`, modus = modusSelect.value;\n    let m;\n    switch (modus) {\n        case 'roundRobin':\n            m = tournament_bracket_1.Modes.ROUND_ROBIN(4);\n            break;\n        case 'swiss':\n            m = tournament_bracket_1.Modes.SWISS;\n            break;\n        case 'tournament':\n        default:\n            m = tournament_bracket_1.Modes.TOURNAMENT;\n            m.maxNumberTeams = 8;\n    }\n    modi.push(m);\n    createBracketModusDiv(modi.length - 1, modus);\n    createTournamentButton.disabled = isTournamentButtonDisabled();\n}\nfunction removeModus(index) {\n    modi.splice(index, 1);\n    const div = document.getElementById(`modus_${index}`);\n    div.remove();\n    updateModiIndices();\n    createTournamentButton.disabled = isTournamentButtonDisabled();\n}\nfunction updateModus(index, modus) {\n    let m;\n    switch (modus) {\n        case 'roundRobin':\n            m = tournament_bracket_1.Modes.ROUND_ROBIN(4);\n            break;\n        case 'swiss':\n            m = tournament_bracket_1.Modes.SWISS;\n            break;\n        case 'tournament':\n        default:\n            m = tournament_bracket_1.Modes.TOURNAMENT;\n            m.maxNumberTeams = 8;\n    }\n    modi[index] = m;\n}\nfunction getNextMatches() {\n    return tournament.nextMatches();\n}\nfunction nextRound() {\n    const matches = getNextMatches();\n    return matches;\n}\nfunction nextModus() {\n    buttonsDiv.classList.remove('next-modus');\n    overlay.classList.remove('next-modus');\n    if (!tournament.hasNextModus()) {\n        tournamentOver();\n        return;\n    }\n    overlay.classList.add('hidden');\n    tournament.nextModus();\n    startNextRound();\n    sessionStorage.setItem('tournament', JSON.stringify(tournament));\n}\nfunction tournamentOver() {\n    overlay.classList.remove('hidden');\n    overlay.classList.add('tournament-over');\n    console.log(tournament, tournament.winner);\n    sessionStorage.removeItem('tournament');\n}\nfunction isTournamentButtonDisabled() {\n    return modi.length === 0 || teams.length === 0;\n}\nfunction updateModiIndices() {\n    let index = 0;\n    for (const modus of modiDiv.children) {\n        modus.id = `modus_${index++}`;\n    }\n}\nfunction createBracketModusDiv(index, mode) {\n    const div = document.createElement('div');\n    div.id = `modus_${index}`;\n    div.classList.add('modus');\n    const mainBracketModus = document.createElement('div');\n    mainBracketModus.classList.add('bracket-mode');\n    const select = document.createElement('select');\n    let option = document.createElement('option');\n    option.value = 'roundRobin';\n    option.innerText = 'Round Robin';\n    select.appendChild(option);\n    option = document.createElement('option');\n    option.value = 'tournament';\n    option.innerText = 'Tournament';\n    select.appendChild(option);\n    option = document.createElement('option');\n    option.value = 'swiss';\n    option.innerText = 'Swiss Stage';\n    select.appendChild(option);\n    select.value = mode;\n    select.addEventListener('change', function () {\n        updateModus(+this.parentElement.id.substring(this.parentElement.id.indexOf('_') + 1), this.value);\n    });\n    mainBracketModus.appendChild(select);\n    const deleteButton = document.createElement('button');\n    deleteButton.textContent = 'X';\n    deleteButton.addEventListener('click', function () {\n        removeModus(+this.parentElement.id.substring(this.parentElement.id.indexOf('_') + 1));\n    });\n    mainBracketModus.appendChild(deleteButton);\n    div.appendChild(mainBracketModus);\n    switch (mode) {\n        case 'roundRobin':\n            addModusOption(div, 'number of rounds', 4, function () {\n                const div = this.parentElement.parentElement;\n                const index = +div.id.substring(div.id.indexOf('_') + 1);\n                modi[index] = tournament_bracket_1.Modes.ROUND_ROBIN(this.value);\n            });\n            break;\n        case 'tournament':\n            addModusOption(div, 'number of teams', 8, function () {\n                const div = this.parentElement.parentElement;\n                const index = +div.id.substring(div.id.indexOf('_') + 1);\n                modi[index].maxNumberTeams = this.value;\n            });\n            break;\n        case 'swiss':\n            break;\n    }\n    modiDiv.appendChild(div);\n}\nfunction addModusOption(div, label, defaultValue, callback) {\n    const parentDiv = document.createElement('div');\n    const labelEl = document.createElement('label');\n    labelEl.innerText = label;\n    parentDiv.appendChild(labelEl);\n    const input = document.createElement('input');\n    input.type = 'number';\n    input.value = `${defaultValue}`;\n    input.addEventListener('input', callback);\n    parentDiv.appendChild(input);\n    div.appendChild(parentDiv);\n}\nfunction createTeamDiv(id, name) {\n    const div = document.createElement('div');\n    div.classList.add('team', `team_${id}`);\n    const input = document.createElement('input');\n    input.value = name;\n    input.addEventListener('input', (event) => {\n        updateTeamName(id, event.target.value);\n    });\n    div.appendChild(input);\n    const deleteButton = document.createElement('button');\n    deleteButton.textContent = 'X';\n    deleteButton.addEventListener('click', () => removeTeam(id));\n    div.appendChild(deleteButton);\n    teamsDiv.appendChild(div);\n}\nfunction disableAddTeam(value) {\n    if (value.trim() === '') {\n        return true;\n    }\n    return (teams.find((team) => team.name.toLowerCase() === value.toLowerCase().trim()) !== undefined);\n}\nfunction updateScore() {\n    const teamScores = document.getElementsByClassName('team-scores')[0];\n    teamScores.innerHTML = '';\n    const teams = tournament.sortTeams();\n    let place = 1;\n    for (const team of teams) {\n        const li = document.createElement('li');\n        li.classList.add('team-score');\n        const teamName = document.createElement('h3');\n        teamName.innerText = `${place++}. ${team.name}`;\n        li.appendChild(teamName);\n        const score = document.createElement('h3');\n        score.innerText = `${team.gameScore.win} - ${team.gameScore.lose}`;\n        const label = document.createElement('span');\n        label.innerText = '';\n        score.appendChild(label);\n        li.appendChild(score);\n        teamScores.appendChild(li);\n    }\n}\nfunction winMatch(div, winnerTeam) {\n    let tableDiv = div;\n    while (!tableDiv.classList.contains('table')) {\n        tableDiv = tableDiv.parentElement;\n    }\n    const matchOrder = tableDiv.id.slice('match__'.length);\n    if (!matchOrder || matchOrder.trim() === '') {\n        console.log('match order was (not yet) set!');\n        return;\n    }\n    const match = matches.filter((match) => match.matchOrder === +matchOrder)[0];\n    if (match.winner ||\n        !confirm(`Confirm that ${match.getTeams()[winnerTeam - 1].name} won the game`)) {\n        return;\n    }\n    tournament.win(match, match.getTeams()[winnerTeam - 1]);\n    sessionStorage.setItem('tournament', JSON.stringify(tournament));\n    tableDiv.classList.add('over');\n    div.classList.add('winner');\n    const ongoingMatches = matches.filter((match) => !match.winner);\n    if (ongoingMatches.length === 0) {\n        if (tournament.modusOver()) {\n            if (tournament.hasNextModus()) {\n                buttonsDiv.classList.add('next-modus');\n                overlay.classList.remove('hidden');\n                overlay.classList.add('next-modus');\n            }\n            else {\n                tournamentOver();\n            }\n        }\n        else {\n            buttonsDiv.classList.add('next-round');\n        }\n    }\n    updateScore();\n}\nfunction addTables() {\n    for (let i = 0; i < tournament.nrSimultaneousGames; ++i) {\n        const div = document.createElement('div');\n        div.classList.add('table', 'over');\n        div.style.left = `${(i % 3) * 230}px`;\n        div.style.top = `${(i > 2 ? 1 : 0) * 400}px`;\n        const moveIcon = document.createElement('div');\n        moveIcon.classList.add('move-icon');\n        moveIcon.innerText = '';\n        div.appendChild(moveIcon);\n        const tableContent = document.createElement('div');\n        tableContent.classList.add('table-content');\n        const team1 = document.createElement('div');\n        team1.classList.add('team', 'team1');\n        team1.addEventListener('click', function () {\n            winMatch(this, 1);\n        });\n        tableContent.appendChild(team1);\n        const divider = document.createElement('span');\n        tableContent.appendChild(divider);\n        const team2 = document.createElement('div');\n        team2.classList.add('team', 'team2');\n        team2.addEventListener('click', function () {\n            winMatch(this, 2);\n        });\n        tableContent.appendChild(team2);\n        div.appendChild(tableContent);\n        tablesDiv.appendChild(div);\n    }\n    const tables = document.getElementsByClassName('table');\n    for (const table of tables) {\n        table.addEventListener('mousedown', (event) => {\n            let target = event.target;\n            while (!target.classList.contains('table') && target.parentElement) {\n                target = target.parentElement;\n            }\n            xDiff = event.clientX - target.offsetLeft;\n            yDiff = event.clientY - target.offsetTop;\n            targetElement = target;\n            document.addEventListener('mousemove', onMouseMove);\n        });\n    }\n}\nfunction onMouseMove(event) {\n    targetElement.style.left = `${event.clientX - xDiff}px`;\n    targetElement.style.top = `${event.clientY - yDiff}px`;\n}\ndocument.addEventListener('mouseup', () => {\n    targetElement = null;\n    document.removeEventListener('mousemove', onMouseMove, false);\n});\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://tournament-bracket/./dist/index.js?");

/***/ }),

/***/ "./dist/model.js":
/*!***********************!*\
  !*** ./dist/model.js ***!
  \***********************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Match = exports.Team = void 0;\nclass Team {\n    static from(team) {\n        const t = new Team(team._id, team._name, team.elo);\n        t._gameScore = team._gameScore;\n        return t;\n    }\n    _id;\n    _name;\n    elo;\n    _gameScore = { win: 0, lose: 0 };\n    constructor(id, name, elo = 1000) {\n        if (elo <= 0 && !Number.isInteger(elo)) {\n            throw Error('Seed must be a positive integer');\n        }\n        this._id = id;\n        this._name = name;\n        this.elo = elo;\n    }\n    draw() {\n        // handle drawing\n    }\n    win(other) {\n        // handle winning\n        this.elo += 30 * (1 - this.calculateWinProbability(other));\n        this._gameScore.win++;\n    }\n    lose(other) {\n        // handle losing\n        this.elo += 30 * (0 - this.calculateWinProbability(other));\n        this._gameScore.lose++;\n    }\n    calculateWinProbability(other) {\n        return 1 / (1 + Math.pow(10, (this.elo - other.elo) / 400));\n    }\n    get id() {\n        return this._id;\n    }\n    get name() {\n        return this._name;\n    }\n    get gameScore() {\n        return this._gameScore;\n    }\n    compare(other) {\n        if (!other) {\n            return 0;\n        }\n        return other.elo - this.elo;\n    }\n    equals(other) {\n        if (this && !other) {\n            return false;\n        }\n        return this._id === other._id;\n    }\n    toString() {\n        return `${this._name} (${this.id})`;\n    }\n}\nexports.Team = Team;\nclass Match {\n    equals(other) {\n        return this._matchOrder === other._matchOrder;\n    }\n    static from(match, allTeams) {\n        const m = new Match(allTeams.find((team) => team.equals(match.team1)), allTeams.find((team) => team.equals(match.team2)), match._matchOrder);\n        m._winner = match._winner;\n        return m;\n    }\n    team1;\n    team2;\n    _winner = 0;\n    _matchOrder;\n    constructor(team1, team2, matchOrder) {\n        this.team1 = team1;\n        this.team2 = team2;\n        this._matchOrder = matchOrder;\n    }\n    done(winner) {\n        this.played(winner);\n    }\n    played(winner) {\n        if (!winner) {\n            if (this.team2) {\n                this.team1.draw();\n                this.team2.draw();\n            }\n            return;\n        }\n        if (!(winner.equals(this.team1) || winner.equals(this.team2))) {\n            throw new Error(`<ERROR> ${winner} is not part of this match`);\n        }\n        if (!this.team2) {\n            // no second team set, so team 1 just moves on\n            this._winner = 1;\n            return;\n        }\n        if (winner.equals(this.team1)) {\n            this._winner = 1;\n            this.team1.win(this.team2);\n            this.team2.lose(this.team1);\n        }\n        else {\n            this._winner = 2;\n            this.team1.lose(this.team2);\n            this.team2.win(this.team1);\n        }\n    }\n    getTeams() {\n        return [this.team1, this.team2];\n    }\n    get winner() {\n        if (this._winner === 0) {\n            return null;\n        }\n        return this._winner === 1 ? this.team1 : this.team2;\n    }\n    get matchOrder() {\n        return this._matchOrder;\n    }\n}\nexports.Match = Match;\n//# sourceMappingURL=model.js.map\n\n//# sourceURL=webpack://tournament-bracket/./dist/model.js?");

/***/ }),

/***/ "./dist/round-robin.js":
/*!*****************************!*\
  !*** ./dist/round-robin.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RoundRobin = void 0;\nconst bracket_mode_1 = __webpack_require__(/*! ./bracket-mode */ \"./dist/bracket-mode.js\");\nconst model_1 = __webpack_require__(/*! ./model */ \"./dist/model.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"./dist/util.js\");\nclass RoundRobin extends bracket_mode_1.BracketMode {\n    numberOfGamesPerTeam = {};\n    numberOfRounds;\n    waitingMatches = [];\n    addWaitingMatches = false;\n    matchCounter = 0;\n    constructor(numberOfRounds) {\n        super('RoundRobin');\n        this.numberOfRounds = numberOfRounds;\n    }\n    static from(r) {\n        const roundRobin = new RoundRobin(r.numberOfRounds);\n        roundRobin.setProperties(r);\n        roundRobin.numberOfGamesPerTeam = r.numberOfGamesPerTeam;\n        roundRobin.waitingMatches = r.waitingMatches.map((match) => model_1.Match.from(match, roundRobin.teams));\n        roundRobin.addWaitingMatches = r.addWaitingMatches;\n        roundRobin.matchCounter = r.matchCounter;\n        return roundRobin;\n    }\n    eliminatesTeam() {\n        return false;\n    }\n    get isContinous() {\n        return true;\n    }\n    get winner() {\n        if (!this.isOver()) {\n            return null;\n        }\n        return this.sortTeams()[0];\n    }\n    isOver() {\n        return (this.tournamentOver ||\n            (this.matches.filter((match) => !match.winner).length === 0 &&\n                this.waitingMatches.length === 0));\n    }\n    getWaitingMatches() {\n        return this.waitingMatches;\n    }\n    createBracket() {\n        (0, util_1.shuffleArray)(this.teams);\n        if (this.teams.length % 2) {\n            this.teams.unshift(null);\n            this.addWaitingMatches = true;\n        }\n        this.setMatches();\n    }\n    nextRound() {\n        this.matches = this.matches.filter((match) => !match.winner);\n    }\n    setMatches() {\n        for (let i = 0; i < this.numberOfRounds; ++i) {\n            const size = this.teams.length;\n            if (i % 2 === 0 && this.addWaitingMatches) {\n                this.waitingMatches.push(new model_1.Match(this.teams[size - 1], this.teams[size - 2], this.matchCounter++));\n            }\n            for (let i = 0; i < size / 2; ++i) {\n                // we insert the \"top row\" team as team1 since that team may never be null\n                if (!this.teams[i]) {\n                    continue;\n                }\n                const match = new model_1.Match(this.teams[size - (i + 1)], this.teams[i], this.matchCounter++);\n                this.addMatch(match);\n            }\n            this.shiftTeams();\n        }\n    }\n    addMatch(match) {\n        this.matches.push(match);\n        if (match.getTeams()[1]) {\n            match.getTeams().forEach((team) => {\n                if (this.numberOfGamesPerTeam[team.id]) {\n                    this.numberOfGamesPerTeam[team.id]++;\n                }\n                else {\n                    this.numberOfGamesPerTeam[team.id] = 1;\n                }\n            });\n        }\n        else if (!this.numberOfGamesPerTeam[match.getTeams()[0].id]) {\n            this.numberOfGamesPerTeam[match.getTeams()[0].id] = 0;\n        }\n    }\n    shiftTeams() {\n        const shiftedTeams = [this.teams[0]];\n        shiftedTeams.push(this.teams[this.teams.length - 1]);\n        for (let i = 1; i < this.teams.length - 1; ++i) {\n            shiftedTeams.push(this.teams[i]);\n        }\n        this.teams = shiftedTeams;\n    }\n    get gamesPerTeam() {\n        return this.numberOfGamesPerTeam;\n    }\n}\nexports.RoundRobin = RoundRobin;\n//# sourceMappingURL=round-robin.js.map\n\n//# sourceURL=webpack://tournament-bracket/./dist/round-robin.js?");

/***/ }),

/***/ "./dist/swiss.js":
/*!***********************!*\
  !*** ./dist/swiss.js ***!
  \***********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Swiss = void 0;\nconst bracket_mode_1 = __webpack_require__(/*! ./bracket-mode */ \"./dist/bracket-mode.js\");\nclass Swiss extends bracket_mode_1.BracketMode {\n    static from(s) {\n        throw new Error('Method not implemented.');\n    }\n    get winner() {\n        throw new Error('Method not implemented.');\n    }\n    isOver() {\n        throw new Error('Method not implemented.');\n    }\n    get isContinous() {\n        throw new Error('Method not implemented.');\n    }\n    canDraw() {\n        throw new Error('Method not implemented.');\n    }\n    nextRound() {\n        throw new Error('Method not implemented.');\n    }\n    eliminatesTeam() {\n        throw new Error('Method not implemented.');\n    }\n    win(match, winner) {\n        throw new Error('Method not implemented.');\n    }\n    createBracket() { }\n}\nexports.Swiss = Swiss;\n//# sourceMappingURL=swiss.js.map\n\n//# sourceURL=webpack://tournament-bracket/./dist/swiss.js?");

/***/ }),

/***/ "./dist/tournament-bracket.js":
/*!************************************!*\
  !*** ./dist/tournament-bracket.js ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Team = exports.Modes = exports.TournamentBracket = void 0;\nconst bracket_type_1 = __webpack_require__(/*! ./bracket-type */ \"./dist/bracket-type.js\");\nconst model_1 = __webpack_require__(/*! ./model */ \"./dist/model.js\");\nObject.defineProperty(exports, \"Team\", ({ enumerable: true, get: function () { return model_1.Team; } }));\nconst Modes = {\n    ROUND_ROBIN(numberOfRounds) {\n        return new bracket_type_1.RoundRobin(numberOfRounds);\n    },\n    SWISS: new bracket_type_1.Swiss('Swiss'),\n    TOURNAMENT: new bracket_type_1.Tournament(),\n};\nexports.Modes = Modes;\nclass TournamentBracket {\n    _modi = [];\n    activeBracket = 0;\n    matchesCanDraw = true;\n    _simultaneousGames = 1;\n    activeMatches = [];\n    constructor(matchesCanDraw) {\n        this.matchesCanDraw = matchesCanDraw;\n    }\n    static from(t) {\n        const tournament = new TournamentBracket(t.matchesCanDraw);\n        tournament._modi = t._modi.map((modus) => {\n            let mode;\n            switch (modus._mode) {\n                case 'RoundRobin':\n                    mode = bracket_type_1.RoundRobin.from(modus);\n                    break;\n                case 'Tournament':\n                    mode = bracket_type_1.Tournament.from(modus);\n                    break;\n                case 'Swiss':\n                    mode = bracket_type_1.Swiss.from(modus);\n                    break;\n            }\n            return mode;\n        });\n        tournament.activeBracket = t.activeBracket;\n        tournament._simultaneousGames = t._simultaneousGames;\n        tournament.activeMatches = t.activeMatches.map((match) => tournament._modi[tournament.activeBracket].matches.find((m) => m.equals(match)));\n        return tournament;\n    }\n    get winner() {\n        if (this.hasNextModus() || !this.modus.isOver()) {\n            return null;\n        }\n        return this.modus.winner;\n    }\n    start() {\n        this.activeBracket = 0;\n        this.createBracket();\n    }\n    modusOver() {\n        return this.modus.isOver();\n    }\n    createBracket() {\n        this.modus.createBracket();\n    }\n    hasNextModus() {\n        return this.activeBracket + 1 < this.modi.length;\n    }\n    nextModus() {\n        if (!this.hasNextModus()) {\n            console.log('tournament over');\n            return false;\n        }\n        this.activeBracket++;\n        const oldModus = this.modi[this.activeBracket - 1];\n        const newModus = this.modi[this.activeBracket];\n        oldModus.endTournament();\n        oldModus.sortTeams();\n        const teams = oldModus.teams;\n        newModus.teams = teams.slice(0, newModus.maxNumberTeams);\n        newModus.createBracket();\n        return true;\n    }\n    sortTeams() {\n        return this.modus.sortTeams();\n    }\n    win(match, winner) {\n        if (!this.activeMatches.includes(match)) {\n            throw new Error(\"<ERROR> Match isn't played right now\");\n        }\n        if (match.winner) {\n            throw new Error('<ERROR> Match already has a winner!');\n        }\n        this.modus.win(match, winner, this.matchesCanDraw);\n    }\n    currentMatches() {\n        const playingTeams = this.activeMatches\n            .flatMap((match) => match.getTeams())\n            .filter((team) => team !== null);\n        playingTeams.sort((a, b) => a.id.localeCompare(b.id));\n        let duplicate = false;\n        playingTeams.forEach((team, index) => {\n            if (team.equals(playingTeams[index + 1])) {\n                duplicate = true;\n            }\n        });\n        if (duplicate) {\n            throw new Error('<ERROR> DUPLICATE FOUND!');\n        }\n        return this.activeMatches;\n    }\n    nextMatches() {\n        let unfinishedMatches = this.activeMatches.filter((match) => !match.winner).length > 0;\n        if (unfinishedMatches) {\n            console.error('Some matches are still ongoing!');\n            return this.activeMatches;\n        }\n        let waitingMatches = this.modus.getWaitingMatches();\n        this.activeMatches.splice(0);\n        let matches = this.modus.matches\n            .filter((match) => !match.winner)\n            .slice(0, this.nrSimultaneousGames);\n        if (matches.length >= this.nrSimultaneousGames) {\n            matches = this.insertPotentialWaitingMatches(waitingMatches, matches);\n            this.activeMatches = matches;\n            return this.activeMatches;\n        }\n        if (this.modus.isContinous || matches.length === 0) {\n            this.modus.nextRound();\n            const newMatches = this.modus.matches\n                .filter((match) => !match.winner)\n                .slice(0, this.nrSimultaneousGames - matches.length);\n            for (const match of newMatches) {\n                if (!matches.includes(match)) {\n                    matches.push(match);\n                }\n            }\n        }\n        matches = this.insertPotentialWaitingMatches(waitingMatches, matches);\n        this.activeMatches = matches;\n        return this.activeMatches;\n    }\n    insertPotentialWaitingMatches(waitingMatches, insertInto) {\n        if (waitingMatches.length === 0) {\n            return insertInto;\n        }\n        let matchInserted = false;\n        const insertTeams = new Set(insertInto\n            .slice(0, this.nrSimultaneousGames - 1)\n            .flatMap((match) => match.getTeams()));\n        for (let i = 0; i < waitingMatches.length; ++i) {\n            let teams = waitingMatches[i].getTeams();\n            if (!insertTeams.has(teams[0]) && !insertTeams.has(teams[1])) {\n                insertInto.unshift(waitingMatches[i]);\n                if (insertInto.length >= this.nrSimultaneousGames) {\n                    insertInto = insertInto.slice(0, this.nrSimultaneousGames);\n                }\n                this.modus.matches.push(...waitingMatches.splice(i, 1));\n                matchInserted = true;\n                break;\n            }\n        }\n        if (matchInserted && waitingMatches.length > 0) {\n            insertInto = this.insertPotentialWaitingMatches(waitingMatches, insertInto);\n        }\n        return insertInto;\n    }\n    setTeams(...teams) {\n        this.modus.teams = teams;\n    }\n    get teams() {\n        return this.modus.teams;\n    }\n    setModi(...modi) {\n        this.modi = modi;\n    }\n    addModus(modus) {\n        this.modi.push(modus);\n    }\n    set modi(modi) {\n        this._modi = modi;\n        this._modi.forEach((mode) => { });\n    }\n    get modi() {\n        return this._modi;\n    }\n    set nrSimultaneousGames(value) {\n        this._simultaneousGames = value;\n    }\n    get nrSimultaneousGames() {\n        return this._simultaneousGames;\n    }\n    get modus() {\n        return this.modi[this.activeBracket];\n    }\n}\nexports.TournamentBracket = TournamentBracket;\n//# sourceMappingURL=tournament-bracket.js.map\n\n//# sourceURL=webpack://tournament-bracket/./dist/tournament-bracket.js?");

/***/ }),

/***/ "./dist/tournament.js":
/*!****************************!*\
  !*** ./dist/tournament.js ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Tournament = void 0;\nconst bracket_mode_1 = __webpack_require__(/*! ./bracket-mode */ \"./dist/bracket-mode.js\");\nconst model_1 = __webpack_require__(/*! ./model */ \"./dist/model.js\");\nclass Tournament extends bracket_mode_1.BracketMode {\n    tournamentWinner = null;\n    matchCounter = 0;\n    constructor() {\n        super('Tournament');\n    }\n    get isContinous() {\n        return false;\n    }\n    eliminatesTeam() {\n        return true;\n    }\n    createBracket() {\n        this.startTournament();\n    }\n    static from(t) {\n        const tournament = new Tournament();\n        tournament.setProperties(t);\n        tournament.tournamentWinner = t.tournamentWinner;\n        tournament.matchCounter = t.matchCounter;\n        return tournament;\n    }\n    isOver() {\n        return this.tournamentOver;\n    }\n    win(match, winner, canDraw) {\n        super.win(match, winner, canDraw);\n        if (this.matches.length === 1) {\n            this.tournamentWinner = winner;\n            this.endTournament();\n        }\n    }\n    get winner() {\n        return this.tournamentWinner;\n    }\n    nextRound() {\n        if (this.isOver()) {\n            console.log('tournament is over, winner is', this.tournamentWinner);\n            this.matches.splice(0);\n            return;\n        }\n        if (this.matches.length === 0) {\n            // first round -> create tournament bracket\n            this.createTournamentBracket();\n            return;\n        }\n        const teams = [];\n        for (const m of this.matches) {\n            if (!m.winner) {\n                throw new Error(`Winner of match ${m} not yet set!`);\n            }\n            teams.push(m.winner);\n        }\n        this.matches.splice(0);\n        for (let i = 0; i < teams.length; i += 2) {\n            this.matches.push(new model_1.Match(teams[i], teams[i + 1], this.matchCounter++));\n        }\n        if (this.matches.length === 1 && !this.matches[0].getTeams()[1]) {\n            this.endTournament();\n        }\n    }\n    createTournamentBracket() {\n        const nrOfRounds = Math.ceil(Math.log2(this.teams.length));\n        const nrOfTeams = Math.pow(2, nrOfRounds);\n        this.matches.splice(0);\n        // bits is of size 3\n        let counter = Array(nrOfRounds).fill(0), bits = Array(nrOfRounds).fill(false);\n        for (let i = 0; i < nrOfRounds; ++i) {\n            counter[i] = Math.pow(2, i);\n        }\n        const sortedTeams = Array(nrOfTeams).fill(null);\n        for (let i = 0; i < nrOfTeams; ++i) {\n            let pos = 0;\n            bits.forEach((v, i) => {\n                pos += v ? Math.pow(2, nrOfRounds - (i + 1)) : 0;\n            });\n            sortedTeams[pos] = this.teams[i] || null;\n            // update bit values\n            counter.forEach((v, i) => {\n                counter[i]--;\n                if (v === 1) {\n                    counter[i] = Math.pow(2, i + 1);\n                    bits[i] = !bits[i];\n                }\n            });\n        }\n        for (let i = 0; i < sortedTeams.length; i += 2) {\n            this.matches.push(new model_1.Match(sortedTeams[i], sortedTeams[i + 1], this.matchCounter++));\n        }\n    }\n}\nexports.Tournament = Tournament;\n//# sourceMappingURL=tournament.js.map\n\n//# sourceURL=webpack://tournament-bracket/./dist/tournament.js?");

/***/ }),

/***/ "./dist/util.js":
/*!**********************!*\
  !*** ./dist/util.js ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.shuffleArray = void 0;\n/* Randomize array in-place using Durstenfeld shuffle algorithm */\nconst shuffleArray = (array) => {\n    for (var i = array.length - 1; i > 0; i--) {\n        var j = Math.floor(Math.random() * (i + 1));\n        var temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n};\nexports.shuffleArray = shuffleArray;\n//# sourceMappingURL=util.js.map\n\n//# sourceURL=webpack://tournament-bracket/./dist/util.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./dist/index.js");
/******/ 	
/******/ })()
;